\chapter{MARCO TEÓRICO}

En el presente capítulo se realizará una exploración de los conceptos necesarios a fin de desarrollar el módulo de teleoperación con feedback háptico. En primer lugar, se aborda un acercamiento al ámbito médico dentro del campo de la robótica en cirugías. Asimismo, se explica la estructura de un sistema háptico y las distintas técnicas de aplicación existentes. Por otro lado, se detallan las teorías de diseño cinemático y dinámico en un manipulador, como es el caso del robot UR5. Además, se describe el método de control aplicado en el sistema y las ecuaciones necesarias para su implementación. Por último, se presentan las herramientas de detección y prevención de colisiones en un entorno de trabajo con dos robots manipuladores, junto con la herramienta de visión computacional.


\section{Suturas externas}
Una herida cutánea o externa, desde su generación hasta su cierre, presenta 3 etapas previas a su curación. La Fase inflamatoria, donde se empieza la coagulación de la herida; la fase proliferativa, donde se crean nuevos tejidos que cubrirán la herida, y la fase de remodelación, donde la heridad termina de cicatrizar \cite{Cicatritacion}. El tiempo de duración de cada etapa dependerá de la naturaleza de la herida y su condición al momento de la revisión. Tomando estos factores en cuenta se puede determinarán si es necesario asegurar la conclusión de alguna de las fases mencionadas con una sutura o si, por el contrario, solo desinfectar la zona afectada.

Para los casos de aplicación de suturas, es considerada en el campo médico como el material encargado del cierre de heridas\cite{GONZALEZ-CELY2018}. De este modo, las suturas enfocadas en heridas superficiales se considerarían como suturas externas. El proceso de suturar es el acercamiento de tejidos separados productos de un corte para su correcta cicatrización. Tomando en cuenta el área afectada, puede necesitarse hilos especiales  e instrumental quirúrgico adicional \cite{GONZALEZ-CELY2018}.

    \subsection{Herramientas comunes}
    Dentro de las herramientas básicas para realizar una sutura se encuentra el porta agujas, la pinza, tijeras y el bisturí. Además de estos, se debe complementar con anestésico local.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.75\linewidth]{images/anastesicos.png}
        \caption{Anestésicos locales más utilizados\cite{GONZALEZ-CELY2018}}
        \label{fig:enter-label}
    \end{figure}
    \subsection{Características a considerar}
    Dentro de las características más importantes, está el material de la sutura. Como se describió a principios del capítulo, la sutura también es la denominación del material con el que se realiza el cierre de la herida; pudiendo ser hilos, grapas, bandas adhesivas, etc. Su elección dependerá del tiempo de permanencia requerido y del área a suturar. 

    Para el caso del uso de hilos, el calibre y el tiempo de permanencia del hilo utilizado variará dependiendo del área anatómica a suturar, por ejemplo, una área de alto movimiento, como una articulación, necesitará un tiempo más prolongado. Asimismo, el material del hilo variará dependiendo de la aplicación y condiciones de la piel. 

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/hilos.png}
        \caption{Tipos de hilos en suturas\cite{GONZALEZ-CELY2018}}
        \label{fig:enter-label}
    \end{figure}

    
    \subsection{Técnicas de aplicación de suturas}
    \textbf{Pasos para realizar una sutura}:
    \begin{enumerate}
        \item Limpieza y desinfección de la herida.
        \item Aplicación anestesia local.
        \item Cierre de la herida con sutura de hilo.
        \item Nudo para con doble lazada y luego lazadas simples\cite{GONZALEZ-CELY2018} 
        \item Cubrir área suturada.
    \end{enumerate}



% %explicar la teoria presente en libros
% \section{Método de sutura robótica} %metodologia

% La sutura realizada por robots es crítico al momento de dar por finalizado un proceso quirurgico, su aplicación en laparoscopia 

\section{Definición de los sistemas Háptico}
  

\subsection{Principios de Funcionamiento de la Retroalimentación Háptica en Robótica}

El sentido del tacto es uno de los más importantes para la extracción de características físicas de los objetos que se encuentran en el entorno y se manipulan, ya que permite identificar la dureza y la rugosidad \cite{El_sentido_del_tacto_revision}. De esta forma, combinando la retroalimentación de los otros sentidos, el ser humano es capaz de comprender lo que está manipulando. Es por esto que la parte háptica es necesaria para mejorar la capacidad de acción del ser humano \cite{spence_gallace_touch}. Dentro del ámbito de la sutura, es muy importante la noción de las características físicas del tejido que se está manipulando, ya que de ello dependerá que el método aplique más o menos fuerza al dispositivo de control para realizar la incisión de la aguja o el agarre de la piel para mantener estable el área que se desea perforar. En caso contrario, existe un alto riesgo de dañar los tejidos únicamente basándose en la vista, lo que podría llevar a consecuencias fatales para el paciente durante la operación.

% De este modo, el dispositivo háptico que se utilizará para esta investigación será capaz de transmitir únicamente la información física relacionada con la rigidez del objeto, es decir, la fuerza que opone resistencia del objeto a ser deformado. De esta forma, para el dispositivo háptico deberá ser capaz de transmitir fuerza en un espacio tridimensional. De está forma, el medico será capaz de recibir una retroalimentación de rigidez en cualquier dirección lo que mejorará su acionar al evitar ejercer más fuerza de la debida. Asímismo, el dispositivo transmitirá la fuerza por consecuencia del control de motores internos al sistema de control que usará el cirujano, ya que se buscará que estos imiten la rigidez que se está sensando al final del brazo manipulador. 





\subsection{Caracterización Técnica del Geomagic Touch}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{encabezados/geomagic_touch.png}
    \caption{Dispositivo háptico Geomagic touch de 3D Systems}
    \label{fig:Geomagic_touch_base}
\end{figure}


El dispositivo háptico utilizado para el trabajo de investigación es el Geomagic Touch de la empresa 3D Systems. Este dispositivo cuenta con 6 grados de libertad. De entre estos, los 6 son leidos con encoders y solamente 3 son actuados. Este dispositivo permite al usuario recibir una retroalimentación por las fuerzas que ejercen en cada una de sus 3 articulaciones. De esta forma, será necesario estimar la posición y orientación del gripper y controlar la velocidad máxima de los motores para simular el estímulo háptico. Asímismo, se tendrán hasta 3.3N de fuerza nominal para proyectar el estimulo de la rigidez sobre el usuraio al mando del sistema de control. Ello será sufiente, dado que la superficie a cortar de los tejidos no no debería superar esta fuerza al usarse una aguja afilada. Sin embargo, se estima que el rago de la fuerza de acionamiento pueda no ser suficiente, dada la extención que podría requedrir la manipulación del hilo y la aguja para suturar un área deseadas. De esta forma, el presente trabajo se limitará a su aplicación a heridas abiertas que no requieran salir del rango de operación para la reatroalimentación de fuerza por parte del dispositivo. Asímismo, el dipositivo podrá comunicarse a 1000 Hz lo cual será un componente determinante para determinar el tiempo a la que se podrá actulaizar la ley de control para los motores.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/technical_geomagic_touch.png}
    \caption{Especificaciones técnicas del dispositivo háptico Geomagic touch de 3D Systems}
    \label{fig:enter-label}
\end{figure}

\subsection{Interfaz Háptica-Robótica para Procedimientos Médicos}
Para enlazar el sistema háptico se utilizará el software que brindra la empresa 3D Systems para el sistema operativo Linux. Este software OpenHaptics permitirá desarrollar el controlador en C/C++. De esta forma, como tambien se planea controlar los robots manipuladores en este sistema operativo, se buscará realizar el intercambio de información mediante la publicación y subscripción de nodos en ROS. Además, teniendo en cuenta que el robot manipulador será teleoperado se buscará principalmente controlar la parte del efector final con la punta del lapiz que cuenta el dispositivo háptico, ya que la forma del controlador y el brazo no son similares. Sin embargo, se buscará que llegen a tener posiciones similares para que el moviento sea más fluido. Asímismo, se buscará implementar una interfaz gráfica donde se pueda observar el moviento del robot en tiempo real con Rviz.  Estas tareas serán silimlares a a las vistas en \cite{teleoperation_irb120_geomagic}, donde se realizó un proceso similar para un robot ABB IRB 120. 


\subsection{Adaptación de los Manipuladores para Control de Sutura mediante Háptica}

El dispositivo contará con una adaptación específica para el procedimiento de sutura, ya que este proceso requiere la sujeción de una aguja e hilo. Por lo tanto, se adaptará el dispositivo háptico para cumplir con estos requisitos. Dado que el Geomagic Touch se puede desacoplar, se diseñará un adaptador en forma de lápiz que se acoplará al efector final para desempeñar esta función. Este diseño se basará en un mecanismo similar al presentado en \cite{arm_pivot_joints_stiffness}, donde se logró adaptar un sistema que permite la inserción de los dedos para evaluar el efecto de un punto pivote sobre la rigidez que se mide.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/geomagic_adaptation_example.png}
    \caption{Modificación al efector final del módulo geomagic touch en \cite{arm_pivot_joints_stiffness}}
    \label{fig:enter-label}
\end{figure}

   
\section{Modelo Cinemático del robot serial}

Un robot serial puede representarse como la unión cinemática de distintos cuerpos rígidos conectados por uniones rotativas o de deslizamiento \cite{siciliano_robotics_2009}. Para lograr un control óptimo del efector final del robot, es fundamental comprender cada uno de los elementos presentes en su análisis cinemático. Esto se debe a que el efector final responderá al movimiento generado por la acción realizada en cada extremidad del robot.

La cinemática permite expresar este análisis mediante expresiones matemáticas en función del movimiento de las articulaciones respecto a un punto de referencia, que generalmente es la base del robot. Este análisis se puede desglosar en subtemas según su finalidad: la Cinemática Directa, que calcula la posición y orientación del efector final a partir de los ángulos de rotación de cada articulación; y la Cinemática Inversa, que determina los ángulos de rotación en cada articulación necesarios para posicionar el efector final en coordenadas y orientación deseadas.

    \subsection{Matriz de Transformación}

    Para poder representar correctamente el movimiento de una articulación del robot, debemos considerarlo como un cuerpo rígido; es decir, que no presenta deformación; además que puede ser representado espacialmente por su posición y orientación\cite{siciliano_robotics_2009}. Es dicha representación la que podemos definirla bajo un conjunto de transformaciones tanto de rotación como de traslación.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\linewidth]{images/pos_or.png}
        \caption{Posición y orientación de un cuerpo rígido}
        \label{fig:por_or}
    \end{figure}
    
    Podemos expresar el punto P en los sistemas de referencia $A$ y $B$: 
    
    $
    \begin{cases}
        ^{A}P = ^{A}x\boldsymbol{\hat{x_A}}  + ^{A}y\boldsymbol{\hat{y_A}}+^{A}z\boldsymbol{\hat{z_A}} \\
        ^{B}P = ^{B}x\boldsymbol{\hat{x_B}}  + ^{B}y\boldsymbol{\hat{y_B}}+^{B}z\boldsymbol{\hat{z_B}}
    \end{cases}
    $

    Si proyectamos el punto en $B$ respecto a $A$ podemos realizarlo mediante la operación vectorial producto punto, lo que resulta en:
    
    $
    \begin{cases}
        ^{A}x = ^{B}p \cdot \boldsymbol{\hat{x_A}}\\
        ^{A}y = ^{B}p \cdot \boldsymbol{\hat{y_A}}\\
        ^{A}z = ^{B}p \cdot \boldsymbol{\hat{z_A}}
    \end{cases}
    $

    
    $
    \begin{cases}
        ^{A}x = ^{B}x(\boldsymbol{\hat{x_B}} \cdot \boldsymbol{\hat{x_A}})  + ^{B}y(\boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{x_A}})+^{B}z(\boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{x_A}})\\
        ^{A}y = ^{B}x(\boldsymbol{\hat{x_B}} \cdot \boldsymbol{\hat{y_A}})  + ^{B}y(\boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{y_A}})+^{B}z(\boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{y_A}})\\
        ^{A}z = ^{B}x(\boldsymbol{\hat{x_B}} \cdot \boldsymbol{\hat{z_A}})  + ^{B}y(\boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{z_A}})+^{B}z(\boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{z_A}})
    \end{cases}
    $

    Vectorialmente, podemos expresarlo:
    \begin{equation*}
        \begin{bmatrix}
            ^{A}x\\^{A}y\\^{A}z 
        \end{bmatrix} = 
        \begin{bmatrix}
            \boldsymbol{\hat{x_B}} \cdot \boldsymbol{\hat{x_A}} & \boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{x_A}} & \boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{x_A}} \\
            \boldsymbol{\hat{x_B}} \cdot \boldsymbol{\hat{y_A}} & \boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{y_A}} & \boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{y_A}} \\
            \boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{z_A}} & \boldsymbol{\hat{y_B}} \cdot \boldsymbol{\hat{z_A}} & \boldsymbol{\hat{z_B}} \cdot \boldsymbol{\hat{z_A}}
        \end{bmatrix} \begin{bmatrix}
            ^{B}x \\  ^{B}y \\ ^{B}z
        \end{bmatrix}
    \end{equation*}

    Operando se consigue la expresión matricial correspondiente a la matriz de rotación, esta se define como $^{A}R_B$ \cite{siciliano_robotics_2009}. Si analizamos las rotaciones realizadas en los 3 ejes principales podemos definir 3 matrices elementales de rotación, que son de utilidad al momento de expresar transformaciones en la orientación. 

    \begin{equation}
        R_x(\theta) = 
        \begin{bmatrix}
            \cos{\theta} & -\sin{\theta} & 0\\
            \sin{\theta} & \cos{\theta} & 0\\
            0 & 0 & 1
        \end{bmatrix}
    \end{equation}
    \begin{equation}
        R_y(\theta) = 
        \begin{bmatrix}
            \cos{\theta} & 0 & \sin{\theta} \\
            0 & 1 & 0 \\
            -\sin{\theta} & 0 & \cos{\theta}            
        \end{bmatrix}
    \end{equation}
    \begin{equation}
        R_z(\theta) = 
        \begin{bmatrix}
            1 & 0 & 0\\
            0 & \cos{\theta} & -\sin{\theta}\\
            0 & \sin{\theta} & \cos{\theta}             
        \end{bmatrix}
    \end{equation}

    Para representar una traslación del eje $B$ respecto al eje veremos que se puede traducir en una suma vectorial de la posición del sistema $A$ y el vector $^{A}t_B$
    
 \begin{equation*}
     ^{A}P  = ^{A}t_B +  ^{B}P
 \end{equation*}

 Si juntamos tanto traslación como rotación obtenemos 
 \begin{equation*}
     ^{A}P  = ^{A}t_B +  ^{A}R_B \ ^{B}P
 \end{equation*}

 Matricialmente, podemos reducir la expresión a:
    \begin{equation}        
        \begin{bmatrix}
            ^{A}P\\1  
        \end{bmatrix} = \begin{bmatrix}
            ^{A}R_B & ^{A}t_B \\
             0 & 1
        \end{bmatrix} \begin{bmatrix}
            ^{B}P \\ 1
        \end{bmatrix}
    \end{equation}

 Entonces la matriz resultante representará la matriz de transformación homogénea $^{A}T_B$
    
    \subsection{Cinemática Directa}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/graf2.png}
        \caption{Transformación de coordenadas en una Cadena cinemática abierta \cite{siciliano_robotics_2009}}
        \label{fig:enter-label}
    \end{figure}
    La Cinemática Directa permite encontrar la posición y orientación del efector final, tomando como entrada las transformaciones realizadas en cada una de las extremidades, una después de la otra. Esta cadena de transformaciones homogéneas se puede expresar como una multiplicación de cada matriz de transformación aplicada a las extremidades que representa finalmente la matriz de transformación homogénea general desde la base del robot o sistema de referencia inercial hasta el efector final.

    \begin{equation} \label{t-homog}
        ^{0}T_n = (^{0}T_1)(^{1}T_2)...(^{n-1}T_n)
    \end{equation}

    \subsection{Método Denavit-Hartenberg}

    Este método permite, de manera sistemática, obtener las matrices homogéneas de cada extremidad mediante un conjunto de pasos tomando en cuenta la extremidad anterior.
    \begin{figure}[H]
        \centering
        \includegraphics[width=\linewidth]{images/DH_general.png}
        \caption{Método Denavit-Hartemberg}
        \label{fig:enter-label}
    \end{figure}

   \textbf{Pasos para la elección de los ejes:}
    \begin{itemize}
        \item Eje $z_i$: Se ubica $z_i$ sobre el eje de movimiento de la articulación siguiente. 
        \item El origen de coordenadas se ubica en la intersección de los ejes $z_{i-1}$ y $z_i$. Si los ejes son paralelos se ubica en la intersección de $z_i$ con la normal en común entre $z_{i-1}$ y $z_i$.
        \item Eje $x_i$: Se ubica en dirección de $z_{i-1}$ x $z_i$. Si los ejes son paralelos se ubica en la normal en común entre $z_{i-1}$ y $z_i$.
        \item Eje $y_i$: Se ubica completando el eje coordenado.
        
    \end{itemize}

    \textbf{Parámetros a identificar }
    \begin{itemize}
        \item $\theta_i$: Rotación del eje $x_{i-1}$ a $x_i$ alrededor del eje $z_{i-1}$
        \item $d_i$: Distancia del sistema coordenado $i-1$ a $i$ a lo largo del eje $z_{i-1}$ hasta la intersección de $x_i$ con $z_{i-1}$
        \item $a_i$: Distancia de la intersección de $x_i$ con $z_{i-1}$  a lo largo del eje $x_{i_1}$ hasta sistema coordenado $i$
        \item $\alpha_i$: Rotación del eje $z_{i-1}$ a $z_i$ alrededor del eje $x_{i}$
    \end{itemize}

    Una vez identificado los parámetros para cada sistema, los ubicamos en un cuadro:
    \\
    
    

    \begin{table}[H]
        \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            i & $d_i$ & $\theta_i$ & $a_i$ & $\alpha_i$ \\ \hline
            1 & $d_1$ & $\theta_1$ + $q_1$ & $a_1$& $\alpha_1$ \\ \hline
            2 & $d_2$ & $\theta_2$ + $q_2$ & $a_2$ & $\alpha_2$ \\ \hline
             & &... & &\\ \hline
            n & $d_n$ & $\theta_i$ + $q_n$ & $a_n$ & $\alpha_n$ \\ \hline
        \end{tabular}
            \caption{Tabla con parámetros}
            \label{tab:DH}
        \end{center}
    \end{table}

    
    \begin{table}[H]
        \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            i & $d_i$ & $\theta_i$ & $a_i$ & $\alpha_i$ \\ \hline
            1 & $0.1625$ & $q_1$      & $0$& $-\frac{\pi}{2}$ \\ \hline
            2 & $0$      & $q_2$      & $0.425$ & $0$ \\ \hline
            3 & $0$      & $q_3$       & $0.3922$ & $0$ \\ \hline
            4 & $0.1333$ &$q_4 - \pi$  & $0$ & $\frac{\pi}{2}$ \\ \hline
            5 & $0.0997$ & $q_5+\pi$ & $0$ & $\frac{\pi}{2}$ \\ \hline
            6 & $0.0996$ & $q_6$     & $0$ & $0$ \\ \hline
        \end{tabular}
            \caption{Tabla de parámetros Denavith Hartenberg}
            \label{tab:DH}
        \end{center}
    \end{table}


    Para llevar los parámetros a una Transformación homogénea se toma este orden de para cada movimiento realizado:
    \begin{enumerate}
        \item Rotación $\theta_i$ en el eje $z_{i-1}$
        \item Traslación $d_i$ en el eje $z_{i-1}$
        \item Traslación $a_i$ en el eje $x_{i}$
        \item Rotación $\alpha_i$ en el eje $z_{i}$
    \end{enumerate}
    Multiplicando cada Matriz homogenea se consigue:

    \begin{equation*}
        ^{i-1}T_{i}(\theta_i,d_i,a_i,\alpha_i)= 
        \begin{bmatrix}
            \cos{\theta_i}& -\cos{\alpha_i}\sin{\theta_i} &\sin{\alpha_i}\sin{\theta_i} & a_i\cos{\theta_i} \\
            \sin{\theta_i}& \cos{\alpha_i}\cos{\theta_i} &-\sin{\alpha_i}\cos{\theta_i} & a_i\sin{\theta_i} \\
            0 & \sin{\alpha_i} & \cos{\alpha_i} & d_i \\
            0 & 0 & 0 & 1
        \end{bmatrix}
    \end{equation*}

    La ecuación \ref{t-homog} permite obtener la representación de la posición y orientación del efector final respecto a la base del robot.
       
    
    \subsection{Cinemática Inversa}

    La cinemática inversa permite calcular las configuraciones articulares de cada elemento en la cadena de articulaciones necesario para lograr una posición y orientación deseada.
    El cálculo de la cinemática inversa en robots como el UR5 de 6 grados de libertad resulta tedioso bajo la directriz de métodos de resolución de ecuaciones clásicos, puesto que se encuentran con expresiones no lineales incompatibles a la resolución por sistema de ecuaciones. Por otro lado, existe el método numérico; este forma de resolución es de naturaleza recursiva y hace uso de técnicas como la minimización de una función costo del error respecto a la posición actual y la posicion deseada del efector final.

    El método numérico hace uso de la matriz Jacobiana para su cálculo, ya sea considerando su inversa o su transpuesta.    
    
    \textbf{Matriz Jacobiana}
    \begin{equation}
        \boldsymbol{J} = \frac{\partial f(q)}{\partial q}
    \end{equation}

    El método numérico propuesto es La Resolución por Método de Gradiente, donde se toma una función costo dependiente de los valores articulares del robot, cuya gradiente permitirá encontrar valores para cada articulación acercando la posición del efector final a la posición deseada.

    \textbf{Método Gradiente}\\
    De la cinemática directa:    
    \begin{equation*}
        \boldsymbol{x}_d = f(\boldsymbol{q}) \longrightarrow \boldsymbol{x}_d - f(\boldsymbol{q}) = 0            
    \end{equation*}
    Donde la expresión resultante es el error respecto a la posición deseada. Con esta expresión podemos definir la función costo $g(\boldsymbol{q})$
    \begin{equation*}
        g(\boldsymbol{q}) = \frac{1}{2} \|\boldsymbol{x}_d - f(\boldsymbol{q})\|^2
    \end{equation*}

    Se calcula el gradiente de $g(\boldsymbol{q})$:
    \begin{equation*}
        \nabla g(\boldsymbol{q}) = -(\frac{\partial f(\boldsymbol{q})}{\partial \boldsymbol{q}})^T (\boldsymbol{x}_d - f(\boldsymbol{q}))
    \end{equation*}

    Finalmente, se puede aplicar el método gradiente de manera recursiva mediante un parámetro $\alpha$ que determinará el tamaño de paso en el avance del gradiente hasta encontrar los valores articulares adecuados.
    \begin{equation}
        \boldsymbol{q}_{k+1} = \boldsymbol{q}_k + \alpha\boldsymbol{J}^T (\boldsymbol{q}_k)(\boldsymbol{x}_d-f(\boldsymbol{q}_k))
    \end{equation}
    \textbf{Método por Optimización Cuadrática}\\
    Partiendo de la función costo $g(\boldsymbol{q})$ se define un problema de minimización, con $e$ como el error de posición, de la forma:    
    \begin{mini*}|s|[0]
        {\boldsymbol{\dot{q}}}{\|\boldsymbol{J(q)}\boldsymbol{\dot{q}} - \boldsymbol{e}\|^2}
        {}
        {\label{eq:minimizationProblem1}}
    \end{mini*}
    
    Expandiendo y ordenando podemos plantear un problema cuadrático de la forma: 
    \begin{mini}|s|[0]
        {\boldsymbol{\dot{q}}}{\frac{1}{2}\boldsymbol{\dot{q}}^{T}\boldsymbol{H} + \nabla g(\boldsymbol{q})\boldsymbol{\dot{q}}}
        {}
        {\label{eq:minimizationProblem}}
    \end{mini}
    donde $\boldsymbol{H} =\boldsymbol{J(q)}^{T}\boldsymbol{J(q)} $, como matriz Hesiana y el gradiente $\nabla g(\boldsymbol{q}) = -(\boldsymbol{J(q)}^{T}\boldsymbol{e})^{T}$ 
    % \\

    % $\boldsymbol{q}$ : configuración articular \\
    % $\boldsymbol{\dot{q}}$: velocidad articular \\
    % $\boldsymbol{J(q)}$ : Matriz Jacobiana \\
    % $\boldsymbol{e}$ : error de posición \\
    % $\boldsymbol{H}$ : Matriz Hesiana\\
    % $\nabla g(\boldsymbol{q})$ : Gradiente
    
\section{Modelo Dinámico del robot serial }

El modelo dinámico permite relacionar el movimiento del robot mediante el análisis de la fuerza y torques aplicados en cada articulación. Mediante este análisis se pueden determinar con mayor fiabilidad un sistema de simulación del robot y el modelamiento de un sistema de control adecuado para entornos reales. Sin embargo, encontrar el modelo dinámico de un robot manipulador implica poder determinar variables matriciales que gobiernan el comportamiento del robot, como la matriz de inercia. Ante este problema, existen métodos matemáticos para el diseño de modelos dinámicos, sea de manera analítica, mediante ecuaciones simbólicas; o de manera numérica, mediante recursividad. 

    \subsection{Newton Euler}    
    Este método es de naturaleza recursiva, puesto que los valores se operarán con los obtenidos anteriormente. Es esta naturaleza la que permite obtener la dinámica inversa, donde se consiguen las fuerzas y torques necesarios para lograr un movimiento deseado. Además, permite establecer un algoritmo que, sumado a herramientas computacionales, logra realizar el cálculo con mayor rapidez. 

    El método Newton-Euler realiza un análisis desde la formulación de la $2^{da}$ ley de Newton para traslación y la $2^{da}$ ley de Euler para la rotación.
    \begin{equation*}
        \boldsymbol{f}_i = \boldsymbol{f}_{i+1} + m_i\ddot{\boldsymbol{p}}_{c_i}-m_i\boldsymbol{g}_0
    \end{equation*}
    \begin{equation*}
        \boldsymbol{\mu}_i = \boldsymbol{\mu}_{i+1} - \boldsymbol{f}_{i}\times\boldsymbol{r_{i-1,c_i}}+\boldsymbol{f}_{i+1}\times\boldsymbol{r_{i,c_i}}+\times\boldsymbol{I}_i\times\dot{\boldsymbol{\omega}}_i+\boldsymbol{\omega}_i\times\boldsymbol{I}_i\boldsymbol{\omega}_i
    \end{equation*}

    Para un eslabón $i$ podemos obtener \cite{fundamentos_robo}:
    
    \textbf{Velocidad Angular }
    \begin{equation*}
        \boldsymbol{\omega}_i = \begin{cases}
            ^{i}\boldsymbol{R}_{i-1} (\boldsymbol{\omega}_{i-1} + \dot{q_i}\boldsymbol{z}_{i-1})$ , Si es de rotación$\\
            ^{i}\boldsymbol{R}_{i-1} (\boldsymbol{\omega}_{i-1})\  \  \  \  \ $  , Si es de prismático$
        \end{cases}
    \end{equation*}
    
    \textbf{Aceleración Angular }
    \begin{equation*}
        \dot{\boldsymbol{\omega}_i} = \begin{cases}
            ^{i}\boldsymbol{R}_{i-1} (\dot{\boldsymbol{\omega}}_{i-1} + \ddot{q_i}\boldsymbol{z}_{i-1} + \dot{q_i}\boldsymbol{w}_{i-1}\times\boldsymbol{z}_{i-1})$ , Si es de rotación$\\
            ^{i}\boldsymbol{R}_{i-1} (\dot{\boldsymbol{\omega}}_{i-1})\  \  \  \  \ $  , Si es de prismático$
        \end{cases}
    \end{equation*}
    
    \textbf{Aceleración Lineal}
    \begin{equation*}
        \ddot{\boldsymbol{p}}_i = ^{i}\boldsymbol{R}_{i-1}\ddot{\boldsymbol{p}}_{i-1} + \dot{\boldsymbol{\omega}}_i\times\boldsymbol{r}_{i-1,i}+\boldsymbol{\omega}_i\times(\boldsymbol{\omega}_i\times\boldsymbol{r}_{i-1,i})
    \end{equation*}   
    
    \textbf{Aceleración del centro de masa}
    \begin{equation*}
        \ddot{\boldsymbol{p}}_{c_i} = \ddot{\boldsymbol{p}}_{i} + \dot{\boldsymbol{\omega}}_i\times\boldsymbol{r}_{i,c_i}+\boldsymbol{\omega}_i\times(\boldsymbol{\omega}_i\times\boldsymbol{r}_{i,c_i})
    \end{equation*}   

    Para calcular estos valores adecuadamente se toma como valores iniciales\cite{barrientos_fundamentos_2007}: 

    $\boldsymbol{\omega}_0 = \begin{bmatrix}
        0\\0\\0
    \end{bmatrix}$ \ \ \ , $\dot{\boldsymbol{\omega}}_0 = \begin{bmatrix}
        0\\0\\0
    \end{bmatrix}$ \ \ \, $\dot{\boldsymbol{p}} =\begin{bmatrix}
        0\\0\\0
    \end{bmatrix} - \boldsymbol{g}$ \ \ \ , $\boldsymbol{z}_0 = \boldsymbol{z}_1 = ...= \boldsymbol{z}_n  = \begin{bmatrix}
        0\\0\\0
    \end{bmatrix}$
    
    El cálculo de la fuerza y de torques implicará un cálculo recursivo inverso, es decir, se tomará el valor actual para calcular el anterior.
    \begin{equation}
        \begin{cases}
            \boldsymbol{f}_i = ^{i}\boldsymbol{R}_{i+1} \boldsymbol{f}_{i+1} + m_i\boldsymbol{\ddot{p}}_{c_i}\\
            \boldsymbol{\mu}_i = ^{i}\boldsymbol{R}_{i+1} \boldsymbol{\mu}_{i+1} - \boldsymbol{f}_{i}\times(\boldsymbol{r}_{i-1,i}+\boldsymbol{r}_{i,c_i}) + ^{i}\boldsymbol{R}_{i+1}\boldsymbol{f}_{i+1}\times\boldsymbol{r}_{i,c_i} + \boldsymbol{I}_i\dot{\boldsymbol{\omega}}_i + {\boldsymbol{\omega}}_i\times\boldsymbol{I}_i\boldsymbol{\omega}_i
        \end{cases}
    \end{equation}

    De manera similar a las velocidades y aceleraciones, los valores iniciales estarán expresados por: 
    
    $\boldsymbol{\mu}_{N+1} = \begin{bmatrix}
        0\\0\\0
    \end{bmatrix}$ \ \ \ $\boldsymbol{f}_{N+1} = \begin{bmatrix} 
        0\\0\\0
    \end{bmatrix}$\ \ \ $^N\boldsymbol{R}_{N+1} = \begin{bmatrix}
        1&0&0\\0&1&0\\0&0&1
    \end{bmatrix}$

    Con las expresiones y términos calculados, podemos definir los torques generalizados del modelo dinámico y por consiguiente, el modelo dinámico:
    
    \begin{equation*}
        \boldsymbol{\tau}_i = {\boldsymbol{\mu}_i}^T {^{i}\boldsymbol{R}_{i-1}} 
        \boldsymbol{z}_{i-1}
    \end{equation*}
    
\section{Control por Modo Deslizante}


\subsection{Introducción al control por modo deslizante (SMC)}
El control por modo deslizante (SMC, por sus siglas en inglés) es un enfoque de control no lineal diseñado para dirigir el comportamiento de un sistema hacia un régimen dinámico específico, definido a través de una superficie de deslizamiento. El objetivo es que el sistema "deslice" sobre esta superficie, logrando así que la trayectoria del sistema se mantenga cerca de la deseada a pesar de perturbaciones y no linealidades. Aunque una de las desventajas de este método es el fenómeno de chattering, pequeñas oscilaciones indeseadas en la ley de control, el SMC es especialmente robusto y resistente a variaciones en el sistema y pequeñas perturbaciones. Esto lo convierte en una opción valiosa para aplicaciones en entornos inciertos o dinámicos, como es el caso de la cirugía robótica.

Este método tiene ventajas significativas para el control de sistemas robóticos en contextos donde existen incertidumbres y no linealidades, como en aplicaciones quirúrgicas para sutura. Su robustez permite mantener un rendimiento adecuado a pesar de variaciones inesperadas en el entorno, como el comportamiento dinámico de los tejidos. Además, el SMC es eficaz en el manejo de dinámicas no lineales, facilitando la adaptación a cambios sin necesidad de un modelo preciso del sistema. Su implementación es también relativamente sencilla, ya que se basa en el diseño de superficies de deslizamiento, reduciendo la complejidad matemática requerida en comparación con otros métodos. La flexibilidad en la definición de estas superficies permite adaptar el control a los requisitos específicos de cada tarea, optimizando así el desempeño de los manipuladores robóticos UR5 en entornos quirúrgicos \cite{utkin_sliding_mode_control}.  \cite{emergency_department_overload}

\subsection{Diseño del control SMC}

El \textbf{control por modo deslizante} (Sliding Mode Control, SMC) es una técnica robusta ampliamente utilizada para sistemas no lineales. Su objetivo principal es forzar al sistema a seguir una superficie de deslizamiento, donde la dinámica se vuelve robusta frente a perturbaciones y modelos inexactos. Para ello, se diseña una ley de control que garantice que la trayectoria del sistema converja hacia dicha superficie y permanezca en ella.

Primero se define una función de Lyapunov adecuada para garantizar estabilidad. En este caso, se emplea una función cuadrática:

\[
V(x) = \frac{1}{2} s^2
\]

donde la función de deslizamiento está dada por:

\[
s(x) = \dot{e} + \lambda e
\]

Aquí, \( e = x - x_d \) es el error entre el estado actual \( x \) y el deseado \( x_d \), y \( \lambda \) es una constante positiva que ajusta la convergencia.

Para asegurar estabilidad, deben cumplirse tres condiciones fundamentales:

\begin{itemize}
    \item \( V(x) > 0 \) para todo \( x \neq x_d \) (positividad).
    \item \( \dot{V}(x) < 0 \), lo que implica convergencia hacia la superficie de deslizamiento.
    \item El sistema debe alcanzar la superficie en tiempo finito y luego deslizarse sobre ella.
\end{itemize}

La derivada de Lyapunov es:

\[
\dot{V} = s \dot{s} = s(\ddot{e} + \lambda \dot{e})
\]

A partir del modelo dinámico del manipulador:

\[
\tau = M \cdot \ddot{q} + C \cdot \dot{q} + G
\]

se proyecta al espacio cartesiano mediante el Jacobiano \( J_a \), obteniendo:

\[
\ddot{x} = J_a \cdot M^{-1} \cdot (\tau - C \cdot \dot{q} - G) + \dot{J}_a \cdot \dot{q} \tag{1}
\]

La superficie de deslizamiento en el espacio cartesiano se define como:

\[
S = \dot{x} - \dot{x}_{\text{des}} + \lambda (x - x_{\text{des}})
\]

y su derivada:

\[
\dot{S} = \ddot{x} - \ddot{x}_{\text{des}} + \lambda (\dot{x} - \dot{x}_{\text{des}})
\]

La ley de control se diseña para que:

\[
\dot{S} = -k \cdot S - k_2 \cdot \tanh(k_3 \cdot S)
\]

con ganancias positivas \( k, k_2, k_3 \). Esto garantiza que \( \dot{V} = S^T \dot{S} < 0 \), cumpliendo la condición de estabilidad.

Sustituyendo la ecuación \((1)\) en la expresión de \( \dot{S} \), se obtiene la ecuación final para el torque de control:

\[
\tau = M \cdot J_a^{-1} \cdot \left[ -k \cdot S - k_2 \cdot \tanh(k_3 \cdot S) - \left( \dot{J}_a \cdot \dot{q} - \ddot{x}_{\text{des}} + \lambda (\dot{x} - \dot{x}_{\text{des}}) \right) \right] + C \cdot \dot{q} + G
\]

Esta ley de control garantiza el seguimiento deseado incluso en presencia de perturbaciones, aprovechando la robustez inherente del enfoque SMC.

\begin{itemize}
    \item \textbf{\( \tau \)}: Torque aplicado al sistema.
    \item \textbf{\( M \)}: Matriz de masa (o inercia).
    \item \textbf{\( \ddot{q} \)}: Aceleración generalizada.
    \item \textbf{\( \dot{q} \)}: Velocidad generalizada.
    \item \textbf{\( q \)}: Posición articular.
    \item \textbf{\( C \)}: Matriz de Coriolis y centrífuga.
    \item \textbf{\( G \)}: Vector de fuerzas de gravedad.
    \item \textbf{\( J_a \)}: Jacobiano de la configuración.
    \item \textbf{\( \dot{J}_a \)}: Derivada temporal del Jacobiano.
    \item \textbf{\( x \)}: Posición en el espacio cartesiano.
    \item \textbf{\( \dot{x} \)}: Velocidad cartesiana.
    \item \textbf{\( \ddot{x} \)}: Aceleración cartesiana.
    \item \textbf{\( x_{\text{des}} \)}, \( \dot{x}_{\text{des}} \), \( \ddot{x}_{\text{des}} \): Referencias deseadas.
    \item \textbf{\( \lambda \)}: Ganancia de la superficie de deslizamiento.
    \item \textbf{\( S \)}: Función de deslizamiento.
    \item \textbf{\( \dot{S} \)}: Derivada de la función de deslizamiento.
    \item \textbf{\( k \)}, \textbf{\( k_2 \)}, \textbf{\( k_3 \)}: Ganancias del controlador.
    \item \textbf{\( \tanh \)}: Función tangente hiperbólica, usada para suavizar el control discontinuo.
    \item \textbf{\( \# \)}: Símbolo que representa la pseudoinversa (si aplica).
\end{itemize}



\section{Control por Impedancia}

\begin{equation}
    \boldsymbol{\tau} = \boldsymbol{M} \boldsymbol{J}^{-1} \left[ \left( \ddot{\boldsymbol{x}}_d - \boldsymbol{K}_p \boldsymbol{e}_x - \boldsymbol{K}_d \boldsymbol{e}_{\dot{x}} \right) - \boldsymbol{J} \dot{\boldsymbol{q}} \right] + \boldsymbol{h}(\boldsymbol{q}, \dot{\boldsymbol{q}})
\end{equation}

$Donde:$

\begin{align*}
\bm{\tau} &\in \mathbb{R}^{6} \quad \text{: Vector de torques articulares} \\
\bm{M} &\in \mathbb{R}^{6 \times 6} \quad \text{: Matriz de inercia articular} \\
\bm{J}^{\dagger} &\in \mathbb{R}^{6 \times 7} \quad \text{: Pseudo-inversa del Jacobiano extendido} \\
\bm{J} &\in \mathbb{R}^{7 \times 6} \quad \text{: Jacobiano extendido (posición + cuaternión)} \\
\ddot{\bm{x}}_d &\in \mathbb{R}^{7} \quad \text{: Aceleración cartesiana deseada} \\
\bm{K}_p &\in \mathbb{R}^{7 \times 7} \quad \text{: Matriz de ganancia proporcional} \\
\bm{K}_d &\in \mathbb{R}^{7 \times 7} \quad \text{: Matriz de ganancia derivativa} \\
\bm{e}_x &\in \mathbb{R}^{7} \quad \text{: Error de pose (posición + orientación)} \\
\bm{e}_{\dot{x}} &\in \mathbb{R}^{7} \quad \text{: Error de velocidad cartesiana} \\
\bm{h}(\bm{q}, \dot{\bm{q}}) &\in \mathbb{R}^{6} \quad \text{: Términos no lineales (Coriolis + gravedad)}
\end{align*}